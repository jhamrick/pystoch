"""pystoch.compile

This module contains the operations necessary to compile a normal
python program (with stochastic function calls) into a pystoch
program.

"""

import _ast
import ast
import codegen
import datetime
import hashlib
import os
import pdb
import sys

from _ast import If

def pystoch_compile(source):
    """Compile python to pystoch.

    Parameters
    ----------
    source : string
        If source is a valid path, it will load the source from the
        path and compile that.  If it is not, then it will be treated
        as the text of the source itself and be compiled.

    Returns
    -------
    out : string
        The compiled source

    """
    
    generator = PyStochCompiler()
    generator.compile(source)
    return generator.source

class PyStochCompiler(codegen.SourceGenerator):
    """A visitor class to transform a python abstract syntax tree into
    pystoch.

    This class inherits from pystoch.codegen.SourceGenerator, which is
    a NodeVisitor that transforms a python abstract syntax tree (AST)
    into python code.  The PyStochCompiler takes it one step further,
    overriding the appropriate functions from SourceGenerator in order
    to insert PyStoch necessary code and perform PyStoch
    transformations.

    See Also
    --------
    pystoch.codegen
    pystoch.ast
    _ast
    ast

    """

    def __init__(self):
        """Initialize the PyStochCompiler.

        This initializes the SourceGenerator, and creates a new list
        for pystoch identifiers (in order to avoid hash collisions).

        """
        
        super(PyStochCompiler, self).__init__(' ' * 4, False)
        self.idens = []
        
    def _gen_iden(self, node):
        """Generate a random unique PyStoch identifier.

        All PyStoch identifiers are prefixed by 'PYSTOCHID_', followed
        by an eight-character hexadecimal string.  The hexadecimal is
        the first eight characters of the md5 digest of the current
        date and time concatenated with the hash of `node`.

        All generated ids are stored, and if a collision is detected,
        the function will try again (with a different date and time)
        to generate a unique id.

        Parameters
        ----------
        node : ast.AST
            The node to generate an id for

        Returns
        -------
        out : string
            The identifier for `node`

        """
        
        now = str(datetime.datetime.now())
        nodeid = str(hash(node))
        iden = hashlib.md5(now + nodeid).hexdigest()[:8]
        if iden in self.idens:
            iden = self._gen_iden(node)
        self.idens.append(iden)
        return "PYSTOCHID_%s" % iden

    @property
    def source(self):
        """The source generated by the PyStochCompiler after `compile`
        has been called.

        """
        
        return ''.join(self.result)

    def insert(self, statements):
        """Insert non-node statements into the source.

        This is used for inserting non-node statements into the source
        compilation.  These generally should only be PyStoch-specific
        statements; if they are a statement that needs to be evaluated
        by the PyStoch compiler then this function should NOT be used.

        You can pass in either a list/tuple of statements, or a single
        statement.

        Parameters
        ----------
        statements : string or list or tuple
           The statement or statements to be inserted

        """

        # turn it into a list if it's not already
        if not isinstance(statements, (list, tuple)):
            statements = [statements]

        # write each statement, separated by a newline
        for statement in statements:
            super(PyStochCompiler, self).newline()
            self.write(statement)

    def compile(self, src):
        """Compile python source to pystoch source.

        Parameters
        ----------
        src : string
            If source is a valid path, it will load the source from the
            path and compile that.  If it is not, then it will be treated
            as the text of the source itself and be compiled.

        Returns
        -------
        out : string
            The compiled source

        """

        # read in the source from a file
        if os.path.exists(src):
            source = open(src, 'r').read()
        # ... or just treat src as the actual source
        else:
            source = src

        # parse the source into an AST
        node = ast.parse(source)

        # generate an identifier for the module/file, and push this
        # identifier onto the module stack.  Also push a 0 onto the
        # line stack.
        iden = self._gen_iden(node)
        self.insert([
            "MODULE_STACK.push('%s')" % iden,
            "LINE_STACK.push(0)",
            ""
            ])

        # compile the rest of the module
        self.visit(node)

        # and finally, pop the line and module stacks
        self.insert([
            "LINE_STACK.pop()",
            "MODULE_STACK.pop()",
            ""])

    def newline(self, node=None, extra=0):
        """Insert a newline.
        
        This inserts a newline in the same way as SourceGenerator,
        with the additional catch of incrementing the line stack if
        the node asking for the newline is non-null (if it's null,
        then incrementing the line stack is pointless because nothing
        will happen between now and the next time a newline occurs).

        Parameters
        ----------
        node : ast.AST (default=None)
            The ast node to insert a newline for
        extra : integer (default=0)
            The number of extra newlines to insert

        Notes
        -----
        This function doesn't actually immediately insert a newline,
        it increments the number of newlines to insert and then
        inserts them when write() is called.

        """
        
        # call the parent newline method
        super(PyStochCompiler, self).newline(node=node, extra=extra)
        # return if the node is null
        if node is None: return

        # otherwise, incremet the line stack and then insert another
        # newline
        self.write("LINE_STACK.increment()")
        super(PyStochCompiler, self).newline(node=node, extra=extra)

    def body(self, statements, write_before=None, write_after=None):
        """Write the body statements.

        This is the same as the SourceGenerator body function, with
        the additional parameters of write_before and write_after.
        These parameters allow you to insert extra stuff before and
        after the rest of the statements.

        Parameters
        ----------
        statements : list of ast.AST nodes
            The statements to be written in the body
        write_before : list or string
            The statements to write before the body
        write_after : list or string
            The statements to write after the body

        """

        # increment the level of indentation
        #self.new_line = True
        self.indentation += 1

        # insert the write_before statementss
        if write_before is not None:
            self.insert(write_before)

        # write the actual body statements
        for stmt in statements:
            self.visit(stmt)

        # insert the write_after statements
        if write_after is not None:
            self.insert(write_after)

        # decrement the level of indentation
        self.indentation -= 1

    def body_or_else(self, node, write_before=None, write_after=None):
        """Write a body as well as an else statement, if it exists.

        Parameters
        ----------
        node : ast.AST
            node that has a body and optionally an orelse
        write_before : list or string
            The statements to write before the body
        write_after : list or string
            The statements to write after the body

        See Also
        --------
        pystoch.compile.PyStochCompiler.body

        """
        
        self.body(node.body, write_before=write_before, write_after=write_after)
        if node.orelse:
            self.newline()
            self.write('else:')
            self.body(node.orelse)

    ########### Visitor Functions ###########

    def visit_FunctionDef(self, node):
        self.newline(extra=1)
        self.decorators(node)
        self.newline(node)
        self.write('def %s(' % node.name)
        self.signature(node.args)
        self.write('):')

        write_before = [
            "FUNCTION_STACK.push('%s')" % self._gen_iden(node),
            "LINE_STACK.push(0)"
            ]

        write_after = [
            "LINE_STACK.pop()",
            "FUNCTION_STACK.pop()"
            ]

        self.body(node.body, write_before=write_before, write_after=write_after)

    def visit_ClassDef(self, node):
        have_args = []
        def paren_or_comma():
            if have_args:
                self.write(', ')
            else:
                have_args.append(True)
                self.write('(')

        self.newline(extra=2)
        self.decorators(node)
        self.newline(node)
        self.write('class %s' % node.name)
        for base in node.bases:
            paren_or_comma()
            self.visit(base)

        if hasattr(node, 'keywords'):
            for keyword in node.keywords:
                paren_or_comma()
                self.write(keyword.arg + '=')
                self.visit(keyword.value)
            if node.starargs is not None:
                paren_or_comma()
                self.write('*')
                self.visit(node.starargs)
            if node.kwargs is not None:
                paren_or_comma()
                self.write('**')
                self.visit(node.kwargs)
        self.write(have_args and '):' or ':')

        write_before = [
            "CLASS_STACK.push('%s')" % self._gen_iden(node),
            "LINE_STACK.push(0)"
            ]

        write_after = [
            "",
            'LINE_STACK.pop()',
            'CLASS_STACK.pop()',
            ""
            ]
        
        self.body(node.body, write_before=write_before, write_after=write_after)

    def visit_Return(self, node):
        self.newline(node)
        self.write('return_val = ')
        self.visit(node.value)

        self.insert([
            "LINE_STACK.pop()",
            "FUNCTION_STACK.pop()",
            "return return_val"
            ])
        
    def visit_For(self, node):
        self.newline(node)
        iden = self._gen_iden(node)
        self.write("%s = " % iden)
        self.visit(node.iter)
        self.newline(node)
        super(PyStochCompiler, self).newline()
        self.insert(["LOOP_STACK.push(0)"])
        super(PyStochCompiler, self).newline()
        self.write('for ')
        self.visit(node.target)
        self.write(' in %s:' % iden)

        self.body_or_else(node, write_before="LOOP_STACK.increment()")
        self.insert("LOOP_STACK.pop()")

    def visit_While(self, node):
        self.newline(node)
        iden = self._gen_iden(node)
        self.write("%s = " % iden)
        self.visit(node.test)
        self.newline(node)
        super(PyStochCompiler, self).newline()
        self.insert(["LOOP_STACK.push(0)"])
        super(PyStochCompiler, self).newline()
        self.write('while %s:' % iden)

        self.body_or_else(node, write_before="LOOP_STACK.increment()")
        self.insert("LOOP_STACK.pop()")

    def visit_ListComp(self, node):
        self.newline(node)
        iden = self._gen_iden(node)
        self.write("%s = []" % iden)
        elt = node.elt

        def parse_generator(nodes):
            node = nodes[-1]
            tempnode = ast.For()
            tempnode.target = node.target
            tempnode.iter = node.iter
            # TODO: deal with ifs here...
            if len(nodes) == 1:
                gen = PyStochCompiler()
                gen.visit(elt)
                iden2 = self._gen_iden(gen.source)
                # TODO: this is a placeholder, should be removed when
                # I get around to rewriting nested function calls
                body = [ast.parse("%s = %s" % (iden2, gen.source)),
                        ast.parse("%s.append(%s)" % (iden, iden2))]
            else:
                body = [parse_generator(nodes[:-1])]
            tempnode.body = body
            tempnode.orelse = None
            return tempnode

        self.visit(parse_generator(node.generators))
        return iden
            
    def visit_DictComp(self, node):
        raise NotImplementedError

    def visit_If(self, node):
        iden = self._gen_iden(node)
        self.newline(node)
        self.write("%s = " % iden)
        self.visit(node.test)

        orig_node = node
        elif_idens = []
        while True:
            else_ = node.orelse
            if len(else_) == 1 and isinstance(else_[0], If):
                node = else_[0]
                elif_idens.append(self._gen_iden(node))
                self.newline(node)
                self.write("%s = " % elif_idens[-1])
                self.visit(node.test)
            else:
                break

        node = orig_node
        self.newline(node)
        self.write('if %s:' % iden)
        self.body(node.body)

        i = 0
        while True:
            else_ = node.orelse
            if len(else_) == 1 and isinstance(else_[0], If):
                node = else_[0]
                self.newline()
                self.write('elif %s:' % elif_idens[i])
                self.body(node.body)
                i += 1
            else:
                self.newline()
                self.write('else:')
                self.body(else_)
                break

    def visit_Assign(self, node):
        if isinstance(node.value, _ast.ListComp):
            iden = self.visit(node.value)
            self.newline(node)
            for idx, target in enumerate(node.targets):
                if idx:
                    self.write(', ')
                self.visit(target)
            self.write(' = %s' % iden)

        else:
            super(PyStochCompiler, self).visit_Assign(node)

if __name__ == "__main__":
    infile = sys.argv[1]
    transform = pystoch_compile(infile)

    if infile.endswith(".py"):
        outfile = infile.rstrip(".py") + ".pystoch"
    else:
        outfile = infile + ".pystoch"
    
    of = open(outfile, 'w')
    of.write(transform)
    of.close()
