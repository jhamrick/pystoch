#!/usr/bin/python

import argparse
import compile as c
import os
from stack import Stack
import sys
import tempfile
import traceback
import numpy as np

def pystochfunc(f):
    f.random = True
    return f

class PyStochObj(object):

    def __init__(self):
        self.func_stack = Stack()
        self.line_stack = Stack()
        self.loop_stack = Stack()

        self.db = {}
        self.num_rvs = 0
        self.rvs = []
        self.trace_lh = 0
        
        self.curr_trace = 0
    
    def call(self, func, *args, **kwargs):
        if hasattr(func, "random") and func.random:
            kwargs['PYSTOCHOBJ'] = self
            #print "Calling %s..." % func.__name__
            #self.print_trace()
            return func(*args, **kwargs)

        elif hasattr(func, "erp") and func.erp:
            return self.update_db(func, args)

        else:
            return func(*args, **kwargs)
            
    def print_trace(self):
        print "Func:  ", str(self.func_stack)
        print "Line:  ", str(self.line_stack)
        print "Loop:  ", str(self.loop_stack)


    def update_db(self, erp_curr, args_curr):
        name = "F%s-Li%s-Lo%s" % (self.func_stack.peek(),
                                  self.line_stack.peek(),
                                  self.loop_stack.peek())
        #print name

        if name in self.db:
            erp_db, val, erp_lh, args_db, trace = self.db[name]
            success = True
        else:
            success = False

        if success and erp_curr == erp_db:

            # keep the database the same, except update the trace
            if args_curr == args_db:
                self.db[name] = (erp_curr, val, erp_lh, args_curr, self.curr_trace)
                self.trace_lh += erp_lh

            # rescore ERP with new parameters
            else:
                erp_lh = np.log(erp_curr.prob(val, *args_curr))
                self.db[name] = (erp_curr, val, erp_lh, args_curr, self.curr_trace)
                self.trace_lh += erp_lh

        # sample new randomness
        else:
            val = erp_curr(*args_curr)
            erp_lh = np.log(erp_curr.prob(val, *args_curr))
            self.db[name] = (erp_curr, val, erp_lh, args_curr, self.curr_trace)
            self.trace_lh += erp_lh

        self.num_rvs += 1
        self.rvs.append(name)
        return val

    def clear(self):
        self.trace_lh = 0
        self.db = {}
        self.num_rvs = 0
        self.rvs = []

    def trace_update(self, func, db):
        self.clear()

        func(self)
        db = self.db
        trace_lh = self.trace_lh
        self.curr_trace += 1
        
        return self.trace_lh, self.db, self.curr_trace-1
        
def run(prog, args):
    PYSTOCHOBJ = PyStochObj()

    filename = None
    sys.argv = args
    
    if prog.endswith('.pystoch'):
        filename = prog
    else:
        source = c.pystoch_compile(prog)
        temp = tempfile.NamedTemporaryFile(
            prefix='tmp_', suffix='.pystoch', dir='/tmp', delete=False)
        temp.write(source)
        temp.close()
        filename = temp.name

    try:
        execfile(temp.name, {'PYSTOCHOBJ': PYSTOCHOBJ})
    except:
        traceback.print_exc(file=sys.stderr)
    finally:
        os.remove(temp.name)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Run a PyStoch program.')
    parser.add_argument('program', metavar='file', type=str, nargs=1,
                        help='the PyStoch file to execute')
    parser.add_argument('arguments', metavar='arg', type=str, nargs='*',
                        help='arguments to the PyStoch program')

    args = parser.parse_args()
    run(args.program[0], args.arguments)
    
