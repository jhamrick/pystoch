#!/usr/bin/python

import argparse
import compile as c
import os
from stack import Stack
import sys
import tempfile
import traceback
import numpy as np

class PyStochObj(object):

    def __init__(self):
        self.func_stack = Stack()
        self.line_stack = Stack()
        self.loop_stack = Stack()

        self.db = {}
        self.num_rvs = 0
        self.rvs = []
        self.trace_loglh = 0
        
        self.curr_trace = 0
    
    def call(self, func, *args, **kwargs):
        if hasattr(func, "random") and func.random:
            kwargs['PYSTOCHOBJ'] = self

        if hasattr(func, "erp") and func.erp:
            return self.update_db(func, args)

        return func(*args, **kwargs)
            
    def print_trace(self):
        print "Func:  ", str(self.func_stack)
        print "Line:  ", str(self.line_stack)
        print "Loop:  ", str(self.loop_stack)


    def update_db(self, erp_curr, args_curr):
        """Update the database with the current random choice.

        If the choice already exists in the database via its name
        (determined by stack traces), and its parameters match the
        parameters stored in the database, then we can just reuse the
        old value.  If the parameters don't match, then we recompute
        the likelihood of the stored value.  If the value isn't found
        in the database at all, then we sample a new value and
        calculate its likelihood.  Finally, we update the database
        with the new value and likelihood, if necessary.

        Paramters
        ---------
        erp_curr : function with erp attribute set to True
            The random choice to update the database with
        args_curr : list of arguments
            The arguments to be passed to the random choice

        Returns
        -------
        out : number
            The value of calling erp_curr(*args_curr)

        """
        
        # calculate the name of the current random choice
        name = "%s-%s-%s" % (self.func_stack.peek(),
                             self.line_stack.peek(),
                             self.loop_stack.peek())

        # look up the name in the database
        if name in self.db:
            erp_db, val, erp_loglh, args_db, trace = self.db[name]
            success = True
        else:
            success = False

        # if the random choice was found in the database and the ERP
        # type matches that found in the database
        if success and erp_curr == erp_db:

            # if the args that the current random choice was called
            # with are not the same as those stored in the database
            if args_curr != args_db:
                
                # rescore the log likelihood by drawing from the
                # probability density/mass function for the ERP
                erp_loglh = np.log(erp_curr.prob(val, *args_curr))
                # store the new log likelihood (plus trace marger) in the database
                self.db[name] = (erp_curr, val, erp_loglh, args_curr, self.curr_trace)
                # update the total log likelihood of the trace
                self.trace_loglh += erp_loglh

        # if the erp type changed, then we need to resample
        else:
            # sample a new value from the distribution and calculate
            # its log likelihood
            val = erp_curr(*args_curr)
            erp_loglh = np.log(erp_curr.prob(val, *args_curr))
            

        # update the database to reflect any changes (including that
        # this random choice was used during this trace)
        self.db[name] = (erp_curr, val, erp_loglh, args_curr, self.curr_trace)
        # update the total log likelihood of the trace
        self.trace_loglh += erp_loglh

        # update the total number of random variables encountered
        # during this trace
        self.num_rvs += 1
        # add the name of the random choice to the list of all random
        # choices in this trace
        self.rvs.append(name)

        # return the value of the random choice
        return val

    def clear(self):
        self.trace_loglh = 0
        self.num_rvs = 0
        self.rvs = []

    def trace_update(self, func, db):
        self.clear()

        self.call(func)
        db = self.db
        trace_loglh = self.trace_loglh
        self.curr_trace += 1
        
        return self.trace_loglh, self.db, self.curr_trace-1
        
def run(prog, args):
    PYSTOCHOBJ = PyStochObj()

    filename = None
    sys.argv = [prog] + args
    
    if prog.endswith('.pystoch'):
        filename = prog
    else:
        source = c.pystoch_compile(prog)
        temp = tempfile.NamedTemporaryFile(
            prefix='tmp_', suffix='.pystoch', dir='/tmp', delete=False)
        temp.write(source)
        temp.close()
        filename = temp.name

    try:
        execfile(temp.name, {'PYSTOCHOBJ': PYSTOCHOBJ, 'sys': sys})
    finally:
        os.remove(temp.name)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Run a PyStoch program.')
    parser.add_argument('program', metavar='file', type=str, nargs=1,
                        help='the PyStoch file to execute')
    parser.add_argument('arguments', metavar='arg', type=str, nargs='*',
                        help='arguments to the PyStoch program')

    args = parser.parse_args()
    run(args.program[0], args.arguments)
    
